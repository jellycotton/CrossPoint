# CrossPoint Protocol for AI Agents

このドキュメントは、**CrossPoint** ツールを使用するユーザーと協調してコーディングを行うAIエージェント（あなた）のための仕様書です。
ユーザーは画面上の座標や領域を特定し、それをJSON形式であなたに伝えます。あなたはそれを解釈し、適切なUIコード（Tkinter, HTML/CSS等）を生成する必要があります。

## CrossPoint Pro で追加される機能（参考）
- **Candidates JSON の可視化**: CrossPoint Pro では、AIが提案した候補点（`rx`/`ry`）をユーザーが点として可視化できるワークフローが追加されます。

この仕様書（CrossPoint / 無印）では、AIは **State JSON**（`rect`/`cross`）を唯一の入力として扱い、提案は **State JSON**（または実装コード）で返してください。

## 基本概念

- **Plate**: 画面上の作業エリア。JSONでは `rect`（`x`,`y`,`w`,`h`）で表されます。
- **Sub-Plate**: Plateの中に作る追加の四角形エリア（1枚）。JSONでは `subrect`（`x`,`y`,`w`,`h`）で表されます（任意）。
- **Cross**: Plate内の注目点。JSONでは `cross`（`rx`,`ry`,`x`,`y`）で表されます。
- **単位**: `unit` は通常 `px`。`x`,`y`,`w`,`h` は小数になることもあります（DPI/描画都合）。
- **相対座標**: `rx`,`ry` は $0.0$〜$1.0$（Plate内）。実装側でクランプされるため、AI側も範囲内を前提にしてください。

## 重要: JSONはスナップショット（唯一の根拠）
CrossPointは「座標と領域をJSONで共有する」ためのツールです。あなた（AI）は、**その瞬間にユーザーPC上で動いているCrossPointの見た目やカーソル位置**を参照して推測してはいけません。

- ユーザーが渡すJSONは**スナップショット**であり、**唯一の正**です。
- 「JSONのcrossの位置」は、**数値として与えられた座標/比率**を意味します。
- 「いま画面に表示されているCrossPointのクロス位置」や「現在のウィンドウ配置」から推測して補正しないでください。
- 迷ったら、追加情報を要求するのではなく、まずJSONの値をそのまま使った案を提示してください。

補足: CrossPoint側の見た目設定（例: Overlayの線の太さ）はローカル設定（`settings.json` 等）で保持されることがありますが、これは State JSON の仕様とは無関係です。AIはUI見た目ではなく、ユーザーが貼り付けた State/Candidates JSON の数値のみを根拠にしてください。

### 推奨の受け取り方（AI側の内規）
ユーザーから「JSONのクロスの位置に○○を置いて」と来たら、次のように解釈してください:

- **“このJSONの `rect` / `cross` の値を唯一の入力としてUI配置を決める”**
- 実装は相対座標（`rx/ry`）優先。必要に応じて `rect.w/h` を初期サイズの参考にする。

### ユーザー向けの定型文（誤解防止）
ユーザーがAIに渡すメッセージに、次を添えると誤解が激減します。

"""
以下のJSONはCrossPointが生成したスナップショットです。あなたはCrossPointの実画面を参照せず、このJSONの数値（rect/cross）だけを根拠に配置してください。
"""

UI座標は **「基準となる四角形 (Rect)」** と **「その中の相対位置 (Cross)」** で表現されます。

*   **Rect (Plate)**: 画面上の絶対座標における作業エリア。ウィンドウそのものや、特定のフレームを指します。
*   **Cross (Point)**: Rect内における注目点へのポインタ。`0.0`〜`1.0` の相対座標で管理されます。

## JSONフォーマット

CrossPointで扱うJSONは主に **State JSON** です。

- **State JSON (ユーザー -> AI / AI -> ユーザー)**: Plate（rect）と Cross（cross）を含むスナップショット。

### 1. State (ユーザー -> AI)
ユーザーが「ここにボタンを置きたい」といった意図を示すデータです。

#### 任意: env（DPI/スケール情報）
環境差（Windowsの表示倍率、Tk/CTkのスケーリング等）によるズレの切り分けをしやすくするため、State/Candidates には任意で `env` を含めることがあります。

- `env.dpi_ppi`: Tkが報告する 1インチあたりのピクセル数（例: 96 / 120 / 144）
- `env.ui_scale`: `dpi_ppi / 96.0`（Windows 100% を 1.0 とした倍率）
- `env.tk_scaling`: Tk の `tk scaling` 値

AIは `env` を必須扱いにせず、存在する場合にのみ「ズレ要因の推定」や「診断（scaleが1.0からズレている理由の説明）」に利用してください。

```json
{
  "version": "1.0",
  "basis": "plate",
  "unit": "px",
  "env": {
    "dpi_ppi": 120.0,
    "ui_scale": 1.25,
    "tk_scaling": 1.25
  },
  "rect": {
    "x": 1168,
    "y": 392,
    "w": 1602,
    "h": 1074
  },
  "cross": {
    "rx": 0.5,
    "ry": 0.5,
    "x": 1969.0,
    "y": 929.0
  },
  "monitor": {
    "w": 3840,
    "h": 2160
  }
}
```
*   **重要**: `rect` は「画面内のPlate位置とサイズ」です（`x`,`y`,`w`,`h`）。
*   **重要**: 相対配置は `cross.rx`,`cross.ry` を優先して解釈してください（0.0〜1.0）。
*   `cross.x`,`cross.y` はスナップショット上の絶対座標（参考値）です。`rect` + `rx/ry` から再計算できるので、矛盾があっても補正せず、まず `rx/ry` を優先してください。
*   `subrect` は任意です。存在する場合、**画面座標の四角形**としてサブプレート領域を表します（メインPlate外にあることもあります: 例: 別位置に出るダイアログ）。
*   `monitor` は任意です（存在すれば画面サイズ）。
*   `version`/`basis`/`unit` や未知フィールドは将来拡張の可能性があります。AIは必要フィールド（`rect`,`cross` または `candidates`）以外で失敗しない実装・提案を優先してください。

#### basis について
現行の `basis` は次の文字列です。

- `plate`: rect/cross の基準がPlate
- `screen`: 画面基準（将来/例外用途）

Candidates JSON の `basis` は、次も使われます。

- `subplate`: `candidates[].rx/ry` の基準がサブプレート（`subrect`）

#### 代替ワークフロー（独立領域として扱う）
サブプレートを「メインとは独立した領域」として作業したい場合、AIは `basis: "subplate"` を使わずに、
**State JSON の `rect` 自体をサブプレート相当の四角形として返す**（= rectをサブ側の領域として扱う）方針でも構いません。

- 長所: AI側の計算は常に `rect` 基準で統一できる
- 注意: メインPlateとの関係（同時表示/比較）を1つのJSONで表す用途には向きません

## 出力時の注意（AI）
- JSONは **コードブロック（```json）** でそのまま貼れる形にしてください。


## コーディング指針
1.  **相対座標の活用**: ユーザーから `rx: 0.9` (右端付近) と指示された場合、ハードコーディングせず `relx=0.9` (Tkinter) や `left: 90%` (CSS) のように、親コンテナに対する相対位置での実装を優先してください。
2.  **Rect情報の利用**: `rect.w`, `rect.h` は、ウィンドウの初期サイズ(`geometry`)やアスペクト比の参考にしてください。

---

## ウィンドウサイズ実装のベストプラクティス (Tkinter/High-DPI)

ユーザーから「ウィンドウサイズをJSONの `rect` に合わせて」と指示された場合、特にHigh-DPI環境（Windows 150%スケールなど）でのトラブルを避けるために以下のルールを守ってください。

### 1. 「論理ピクセル (Logical Pixels)」として扱う
JSONの `unit: "px"` は、実装コード上では **論理ピクセル** として扱います。
物理ピクセルへの変換計算（`ctypes` でDPIを取得して割り算するなど）は**不要**です。TkinterやOSのスケーリング機能に任せて、数値をそのまま適用してください。

- **NG**: `width = rect.w / ui_scale` （勝手に割らない）
- **OK**: `width = rect.w` （そのまま渡す）

### 2. 「クライアント領域 (Client Area)」を基準にする
ユーザーが指定する `rect` は、通常「中身のコンテンツが見える領域」を指しています。
`geometry(WxH)` はウィンドウセット全体のサイズではなく、**クライアント領域のサイズ**として適用する意図で実装してください。

- タイトルバーやウィンドウ外周の枠（Non-client area）のサイズを計算して引く必要はありません。
- 指定された `rect.w` / `rect.h` をそのまま `geometry` に設定することで、ユーザーの期待する「中身の広さ」が確保されます。

### 3. 過剰な自動補正をしない
「本当に物理ピクセルが合っているか？」を確認するために、ウィンドウ生成後にスクリーンショット判定やAPI計測を行ってリサイズし直すような**自己補正ロジックは実装しないでください**。
環境ごとの誤差で無限ループや縮小過多に陥る原因になります。「単純に論理サイズの数値を設定する」のが最も安全で互換性の高い実装です。

---
このプロトコルを守ることで、ユーザーの「あそこ」や「この辺」という曖昧な指示を正確なコードに変換できます。

---

## 開発・著作
じぇりー（Jelly）

Bluesky: https://bsky.app/profile/jellycotton.bsky.social

## ライセンス
Copyright (c) 2026 じぇりー (Jelly)

## 利用条件
本ソフトウェアは個人利用を目的として提供されています。
本ソフトウェアの再配布および商用利用は許可していません。
その他の利用については作者にお問い合わせください。
