# CrossPoint Protocol for AI Agents

このドキュメントは、**CrossPoint** ツールを使用するユーザーと協調してコーディングを行うAIエージェント（あなた）のための仕様書です。
ユーザーは画面上の座標や領域を特定し、それをJSON形式であなたに伝えます。あなたはそれを解釈し、適切なUIコード（Tkinter, HTML/CSS等）を生成する必要があります。

## CrossPoint Pro で追加される機能（参考）
- **Candidates JSON の可視化**: CrossPoint Pro では、AIが提案した候補点（`rx`/`ry`）をユーザーが点として可視化できるワークフローが追加されます。

この仕様書（CrossPoint / 無印）では、AIは **State JSON**（`rect`/`cross`）を唯一の入力として扱い、提案は **State JSON**（または実装コード）で返してください。

## 基本概念

- **Plate**: 画面上の作業エリア。JSONでは `rect`（`x`,`y`,`w`,`h`）で表されます。
- **Sub-Plate**: Plateの中に作る追加の四角形エリア（1枚）。JSONでは `subrect`（`x`,`y`,`w`,`h`）で表されます（任意）。
- **Cross**: Plate内の注目点。JSONでは `cross`（`rx`,`ry`,`x`,`y`）で表されます。
- **単位**: `unit` は通常 `px`。`x`,`y`,`w`,`h` は小数になることもあります（DPI/描画都合）。
- **相対座標**: `rx`,`ry` は $0.0$〜$1.0$（Plate内）。実装側でクランプされるため、AI側も範囲内を前提にしてください。

## 重要: JSONはスナップショット（唯一の根拠）
CrossPointは「座標と領域をJSONで共有する」ためのツールです。あなた（AI）は、**その瞬間にユーザーPC上で動いているCrossPointの見た目やカーソル位置**を参照して推測してはいけません。

- ユーザーが渡すJSONは**スナップショット**であり、**唯一の正**です。
- 「JSONのcrossの位置」は、**数値として与えられた座標/比率**を意味します。
- 「いま画面に表示されているCrossPointのクロス位置」や「現在のウィンドウ配置」から推測して補正しないでください。
- 迷ったら、追加情報を要求するのではなく、まずJSONの値をそのまま使った案を提示してください。

補足: CrossPoint側の見た目設定（例: Overlayの線の太さ）はローカル設定（`settings.json` 等）で保持されることがありますが、これは State JSON の仕様とは無関係です。AIはUI見た目ではなく、ユーザーが貼り付けた State/Candidates JSON の数値のみを根拠にしてください。

### 推奨の受け取り方（AI側の内規）
ユーザーから「JSONのクロスの位置に○○を置いて」と来たら、次のように解釈してください:

- **“このJSONの `rect` / `cross` の値を唯一の入力としてUI配置を決める”**
- 実装は相対座標（`rx/ry`）優先。必要に応じて `rect.w/h` を初期サイズの参考にする。

### ユーザー向けの定型文（誤解防止）
ユーザーがAIに渡すメッセージに、次を添えると誤解が激減します。

"""
以下のJSONはCrossPointが生成したスナップショットです。あなたはCrossPointの実画面を参照せず、このJSONの数値（rect/cross）だけを根拠に配置してください。
"""

UI座標は **「基準となる四角形 (Rect)」** と **「その中の相対位置 (Cross)」** で表現されます。

*   **Rect (Plate)**: 画面上の絶対座標における作業エリア。ウィンドウそのものや、特定のフレームを指します。
*   **Cross (Point)**: Rect内における注目点へのポインタ。`0.0`〜`1.0` の相対座標で管理されます。

## JSONフォーマット

CrossPointで扱うJSONは主に **State JSON** です。

- **State JSON (ユーザー -> AI / AI -> ユーザー)**: Plate（rect）と Cross（cross）を含むスナップショット。

### 1. State (ユーザー -> AI)
ユーザーが「ここにボタンを置きたい」といった意図を示すデータです。

#### 任意: env（DPI/スケール情報）
環境差（Windowsの表示倍率、Tk/CTkのスケーリング等）によるズレの切り分けをしやすくするため、State/Candidates には任意で `env` を含めることがあります。

- `env.dpi_ppi`: Tkが報告する 1インチあたりのピクセル数（例: 96 / 120 / 144）
- `env.ui_scale`: `dpi_ppi / 96.0`（Windows 100% を 1.0 とした倍率）
- `env.tk_scaling`: Tk の `tk scaling` 値

AIは `env` を必須扱いにせず、存在する場合にのみ「ズレ要因の推定」や「診断（scaleが1.0からズレている理由の説明）」に利用してください。

```json
{
  "version": "1.0",
  "basis": "plate",
  "unit": "px",
  "env": {
    "dpi_ppi": 120.0,
    "ui_scale": 1.25,
    "tk_scaling": 1.25
  },
  "rect": {
    "x": 1168,
    "y": 392,
    "w": 1602,
    "h": 1074
  },
  "cross": {
    "rx": 0.5,
    "ry": 0.5,
    "x": 1969.0,
    "y": 929.0
  },
  "monitor": {
    "w": 3840,
    "h": 2160
  }
}
```
*   **重要**: `rect` は「画面内のPlate位置とサイズ」です（`x`,`y`,`w`,`h`）。
*   **重要**: 相対配置は `cross.rx`,`cross.ry` を優先して解釈してください（0.0〜1.0）。
*   `cross.x`,`cross.y` はスナップショット上の絶対座標（参考値）です。`rect` + `rx/ry` から再計算できるので、矛盾があっても補正せず、まず `rx/ry` を優先してください。
*   `subrect` は任意です。存在する場合、**画面座標の四角形**としてサブプレート領域を表します（メインPlate外にあることもあります: 例: 別位置に出るダイアログ）。
*   `monitor` は任意です（存在すれば画面サイズ）。
*   `version`/`basis`/`unit` や未知フィールドは将来拡張の可能性があります。AIは必要フィールド（`rect`,`cross` または `candidates`）以外で失敗しない実装・提案を優先してください。

#### basis について
現行の `basis` は次の文字列です。

- `plate`: rect/cross の基準がPlate
- `screen`: 画面基準（将来/例外用途）

Candidates JSON の `basis` は、次も使われます。

- `subplate`: `candidates[].rx/ry` の基準がサブプレート（`subrect`）

#### 代替ワークフロー（独立領域として扱う）
サブプレートを「メインとは独立した領域」として作業したい場合、AIは `basis: "subplate"` を使わずに、
**State JSON の `rect` 自体をサブプレート相当の四角形として返す**（= rectをサブ側の領域として扱う）方針でも構いません。

- 長所: AI側の計算は常に `rect` 基準で統一できる
- 注意: メインPlateとの関係（同時表示/比較）を1つのJSONで表す用途には向きません

## 出力時の注意（AI）
- JSONは **コードブロック（```json）** でそのまま貼れる形にしてください。


## コーディング指針
1.  **相対座標の活用**: ユーザーから `rx: 0.9` (右端付近) と指示された場合、ハードコーディングせず `relx=0.9` (Tkinter) や `left: 90%` (CSS) のように、親コンテナに対する相対位置での実装を優先してください。
2.  **Rect情報の利用**: `rect.w`, `rect.h` は、ウィンドウの初期サイズ(`geometry`)やアスペクト比の参考にしてください。

---

## ウィンドウサイズ実装のベストプラクティス (Tkinter/High-DPI)

ユーザーから「ウィンドウサイズをJSONの `rect` に合わせて」と指示された場合、特にHigh-DPI環境（Windows 150%スケールなど）でのトラブルを避けるために以下のルールを守ってください。

### 3. High-DPI環境での安全な実装指針
アプリの信頼性を高めるためには、OSの拡大率を正しく認識する **「DPI-Aware（可能ならPer-Monitor V2）」** での実装を推奨します。

*   **推奨**: DPI-Aware有効。`1px` = `1論理ピクセル` としてOSのAPIが正しくマッピングします。
*   **妥協案**: どうしても実装が複雑になる場合、DPI-Awareを無効（Unaware）にしてOSの拡大（DWM Scaling）に任せる手もありますが、座標の定義がぼやける可能性があります。

どちらの場合も、JSONの `rect` は **「論理ピクセル」** としてそのまま適用してください。AI側で `rect.w * 1.5` や `rect.w / 1.5` のような手動計算をする必要はありません。

### 4. 過剰な自動補正をしない
「本当に物理ピクセルが合っているか？」を確認するために、ウィンドウ生成後にスクリーンショット判定やAPI計測を行ってリサイズし直すような**自己補正ロジックは実装しないでください**。
環境ごとの誤差で無限ループや縮小過多に陥る原因になります。「単純に論理サイズの数値を設定する」のが最も安全で互換性の高い実装です。

### 5. ライブラリ固有の自動スケーリングに注意（重要）
使用するGUIライブラリによっては、OSの設定とは別に**独自の自動拡大/縮小機能（Auto-Scaling）**がデフォルトで有効になっている場合があります。
（例: `CustomTkinter` はデフォルトでスケーリングを行い、指定した `width=100` を `150` などに勝手に変換して描画することがあります）

- **AIへの指示**: ライブラリを選定する際は、そのライブラリが「数値を勝手に加工しないか」を確認し、必要であれば**自動スケーリングを無効化（1.0に固定）**するか、**標準ライブラリ（tkinter等）**を使用してください。
- ユーザーに提供するコードは、JSONの数値を **論理ピクセル（DIP）** として正しく反映できる構成にしてください。

---
このプロトコルを守ることで、ユーザーの「あそこ」や「この辺」という曖昧な指示を正確なコードに変換できます。

---

### 6. 【開発者向け】ズレが出る典型例とトラブルシューティング（100%の意味）

CrossPointの **State JSON** は、Windowsの表示倍率が 125% / 150% であっても **「論理ピクセル（DIP）」として正しい値** です。
したがって、AIは `env.ui_scale` を使って `rect.w * 1.5` や `rect.w / 1.5` のような手動補正をしてはいけません。値は常に JSONの数値をそのまま使うのが**適切**です。

それでも実装結果がズレる場合、原因はほぼ「実装側が別の座標系で解釈している」ことです。よくある例は次です。

**例1: アプリのDPI Awarenessが違う**
（DPI-aware / Unaware / System-aware の混在）
同じ `geometry(1600x900)` を指定しても、OS側のDPI仮想化（DWM Scaling）が介入し、見た目が巨大化・縮小・位置ズレを起こすことがあります。**これはJSONの誤りではありません。**

**例2: GUIライブラリが独自にAuto-Scalingしている**
（例: `CustomTkinter` など）
`width=100` を内部で `150` のように変換して描画し、JSONの意図と一致しなくなることがあります。必要ならAuto-Scalingを無効化（1.0固定）するか、標準tkinterを使ってください。

**例3: クライアント領域と外枠（タイトルバー込み）を混同している**
JSONの `rect.w / h` を「ウィンドウ外枠サイズ」と誤解すると、余白分だけズレます。JSONの `rect` は **“Plate（作業領域）”** として解釈し、実装側でも同じ対象（クライアント領域）に合わせてください。

**例4: マルチモニタ（混在DPI）で取得したJSONを、別モニタ条件で再現している**
同じPCでも、表示倍率やDPIが異なるモニタへ移動すると座標の意味が変わったように見えることがあります（補正で解決しようとすると悪化しやすい）。

#### 100%（Scale=1.0）の意味

**100%は「正しさの条件」ではありません。**
100%はあくまで **トラブルシューティングを単純化するための基準点** です。

100%環境では、論理と物理の差が最小になり、比較・検証が単純になります。
「ズレた」と感じたときに、同じJSONを **一時的に100%でも再現して差分を観察する** と、原因が「DPI awareness」「ライブラリのAuto-Scaling」「クライアント領域の取り違え」などに絞り込みやすくなります。

> **重要**: 125%/150%で生成されたJSONも常に正しい論理値です。
> 「150%で作ったから 1.5で割る／掛ける」と考える**必要はありません**。

## ライセンス
Copyright (c) 2026 じぇりー (Jelly)

## 免責事項
本ソフトウェアは「現状のまま（AS IS）」提供され、明示または黙示を問わず、いかなる保証も行いません。
作者は、本ソフトウェアの使用または使用不能に起因するいかなる損害（請求、損害、その他の責任）についても責任を負いません。
ご利用は自己責任でお願いします。

## 利用条件
本ソフトウェアは個人が利用することを想定して提供されています。
・ソフトウェア自体の再配布および転売は禁止です。
・本ツールを商用プロジェクト（業務利用や成果物の販売）に使用することは自由です。
その他の利用については作者にお問い合わせください。
