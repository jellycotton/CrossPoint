# CrossPoint Protocol for AI Agents (English)

This document is a specification for AI agents (you) who collaborate with a user using the **CrossPoint** tool.
The user identifies screen regions/points and shares them with you as JSON. You must interpret that JSON and generate appropriate UI code (Tkinter, HTML/CSS, etc.).

## What CrossPoint Pro Adds (FYI)
- **Candidates visualization**: CrossPoint Pro adds a workflow where users can visualize AI-proposed points (`rx`/`ry`) on screen.

In this document (CrossPoint / standard), treat **State JSON** (`rect`/`cross`) as the only input, and return proposals as **State JSON** (or direct implementation code).

## Core Concepts

- **Plate**: The working area on the screen. In JSON, this is `rect` (`x`, `y`, `w`, `h`).
- **Sub-Plate**: An additional rectangular area (one). In JSON, this is `subrect` (`x`, `y`, `w`, `h`) (optional).
- **Cross**: A focus point inside the Plate. In JSON, this is `cross` (`rx`, `ry`, `x`, `y`).
- **Units**: `unit` is usually `px`. `x`, `y`, `w`, `h` may be floats (DPI/rendering).
- **Relative coordinates**: `rx`, `ry` are $0.0$ to $1.0$ (inside the Plate). The app clamps values; the AI should also assume the valid range.

## Important: JSON is a Snapshot (Single Source of Truth)
CrossPoint exists to share **coordinates and regions via JSON**. As an AI, you must not “correct” or infer from what CrossPoint looks like on the user's screen.

- The JSON the user provides is a **snapshot** and the **only truth**.
- The `cross` position means the **numeric coordinates/ratios** given in the JSON.
- Do not try to infer/correct based on the current CrossPoint overlay, cursor position, window placement, etc.
- If you are unsure, do not immediately ask for more info—first propose an implementation based strictly on the JSON values.

Note: CrossPoint's local UI appearance settings (e.g., overlay line thickness saved in `settings.json`) are unrelated to the State/Candidates JSON specification. Only use the numeric values in State/Candidates JSON.

### Recommended Interpretation Rule (AI internal policy)
When the user says “place X at the JSON cross”, interpret it as:

- **Use `rect` / `cross` values in the JSON as the only input for layout.**
- Prefer relative coordinates (`rx`/`ry`). Use `rect.w`/`rect.h` as a hint for initial size if needed.

### Suggested User Message Snippet (to prevent misunderstandings)
Encourage the user to include this (or similar) text when sending JSON:

```
The following JSON is a snapshot generated by CrossPoint.
Do not rely on CrossPoint's on-screen appearance.
Use only these numeric values (rect/cross) as the basis for layout.
```

UI coordinates are expressed as a **reference rectangle (Plate/Rect)** plus a **relative focus point (Cross)**.

## JSON Formats

CrossPoint uses two main JSON formats:

- **State JSON (User → AI / AI → User)**: A snapshot containing Plate (`rect`) and Cross (`cross`).

### 1) State (User → AI)
This is the snapshot that expresses intent like “I want the button around here”.

#### Optional: `env` (DPI / scaling metadata)
To help diagnose and reduce layout mismatches caused by environment differences (Windows display scaling, Tk/CTk scaling, etc.), State/Candidates JSON may optionally include an `env` block.

- `env.dpi_ppi`: pixels-per-inch reported by Tk (e.g., 96 / 120 / 144)
- `env.ui_scale`: `dpi_ppi / 96.0` (Windows 100% == 1.0)
- `env.tk_scaling`: Tk's `tk scaling` value

AI should treat `env` as optional (never required). When present, use it only as a hint to estimate scaling-related drift and to consider correction factors.

```json
{
	"version": "1.0",
	"basis": "plate",
	"unit": "px",
	"env": {
		"dpi_ppi": 120.0,
		"ui_scale": 1.25,
		"tk_scaling": 1.25
	},
	"rect": {
		"x": 1168,
		"y": 392,
		"w": 1602,
		"h": 1074
	},
	"cross": {
		"rx": 0.5,
		"ry": 0.5,
		"x": 1969.0,
		"y": 929.0
	},
	"monitor": {
		"w": 3840,
		"h": 2160
	}
}
```

- **Important**: `rect` is the Plate position and size on the screen.
- **Important**: For layout, prefer `cross.rx` / `cross.ry` ($0.0$–$1.0$).
- `cross.x` / `cross.y` are absolute coordinates in the snapshot (reference). They can be recomputed from `rect` + `rx/ry`. If there is any inconsistency, **do not “fix” it**—prefer `rx/ry`.
- `subrect` is optional. If present, it is an **absolute screen rectangle** representing the Sub-Plate (may be outside the main Plate, e.g., a dialog that appears elsewhere).
- `monitor` is optional.
- Unknown fields may appear in future versions. Prefer implementations that are tolerant of extra fields.

#### About `basis`
Current `basis` values:

- `plate`: `rect`/`cross` are Plate-based
- `screen`: screen-based (future/exceptional use)

Candidates JSON may also use:

- `subplate`: `candidates[].rx/ry` are relative to the Sub-Plate (`subrect`)

#### Alternative Workflow (treat Sub-Plate as an independent area)
If you want to treat Sub-Plate as an independent work area, you may avoid `basis: "subplate"` and instead:

- Return a State JSON where `rect` itself represents the Sub-Plate area (i.e., treat the Sub-Plate rectangle as the main Plate).

Pros: calculations stay consistently `rect`-based.
Cons: not ideal if you need to represent both main Plate and Sub-Plate together in one JSON.

## Output Notes (AI)
- Return JSON in a fenced code block tagged as `json`.


## Coding Guidelines
1. **Use relative coordinates**: If the user says `rx: 0.9` (near the right edge), prefer relative placement such as `relx=0.9` (Tkinter) or `left: 90%` (CSS), rather than hard-coding pixels.
2. **Use `rect` size as a hint**: `rect.w` / `rect.h` can guide initial window size (`geometry`) or aspect ratio.

---

### 5. Typical Alignment Issues and Troubleshooting (Meaning of 100%) [Developer Guide]

CrossPoint **State JSON** values are **correct Logical Pixels (DIP)** even if generated at 125% or 150% Windows display scaling.
Therefore, the AI must NOT manually correct values like `rect.w * 1.5` or `rect.w / 1.5` using `env.ui_scale`. Using the JSON values **as-is** is always appropriate.

If the implementation still results in misalignment, the cause is almost always "the implementation side interpreting the coordinates in a different system". Common examples include:

**Case 1: Mismatched DPI Awareness**
(Mixing DPI-aware / Unaware / System-aware)
Even with the same `geometry(1600x900)`, OS-side DPI virtualization (DWM Scaling) may intervene, causing the window to appear huge, shrunk, or offset. **This is not an error in the JSON.**

**Case 2: GUI Library Auto-Scaling**
(e.g., `CustomTkinter`)
Some libraries convert `width=100` to `150` internally for drawing, conflicting with the JSON's intent. If necessary, disable Auto-Scaling (fix to 1.0) or use standard Tkinter.

**Case 3: Confusing Client Area with Window Frame**
Misinterpreting JSON `rect.w / h` as "Window Outer Size" causes offsets equal to the border/title bar size. JSON `rect` should be interpreted as **"Plate (Working Area)"**, and the implementation should match the same target (Client Area).

**Case 4: Reproducing on different monitors (Mixed DPI)**
Moving to a monitor with different scaling or DPI may make the coordinates seem incorrect (trying to fix this with manual calculation usually makes it worse).

#### The Meaning of 100% (Scale=1.0)

**"100%" is NOT a condition for correctness.**
It is merely a **baseline to simplify troubleshooting**.

In a 100% environment, the difference between logical and physical pixels is minimized, making comparison and verification simple.
If you feel "it's misaligned", **temporarily reproducing it at 100% and observing the difference** helps narrow down the cause to "DPI awareness", "Library Auto-Scaling", "Client Area confusion", etc.

> **Important**: State JSON generated at 125% or 150% is also valid logical data.
> There is **no need to think** "It was made at 150%, so I must divide/multiply by 1.5".

### 3. Safe Implementation Guidelines for High-DPI Environments
 To ensure reliability, it is recommended to implement the app as **"DPI-Aware (Per-Monitor V2 if possible)"** so it correctly recognizes OS scaling.

*   **Recommended**: DPI-Aware enabled. The OS API maps `1px` to `1 logical pixel` correctly.
*   **Compromise**: If implementation is too complex, you can disable DPI Awareness (Unaware) and rely on OS bitmap scaling (DWM Scaling), but coordinate definition may become blurry.

In either case, apply the JSON `rect` as **"Logical Pixels"** directly. The AI does not need to manually calculate `rect.w * 1.5` or `rect.w / 1.5`.

### 2. Base on "Client Area"
The `rect` provided by the user typically refers to the "visible content area."
Implement `geometry(WxH)` as the size of the **Client Area**, not the entire window.

- There is no need to calculate and subtract standard window frame sizes (Non-client area) like title bars.
- By setting the specified `rect.w` / `rect.h` directly in `geometry`, you ensure the user's expected "content space" is preserved.

### 3. Avoid Over-Correction
**Do NOT implement self-correction loops** (e.g., measuring the window after creation and resizing it again) to verify physical pixel accuracy.
Scaling discrepancies across environments can cause infinite loops or excessive shrinking. "Simply setting the logical size value" is the safest and most compatible approach.

---
Following this protocol helps convert vague human instructions (“around here”) into precise, reproducible UI code.

---

## License / Usage Terms
### Development / Copyright
Jelly

Bluesky: https://bsky.app/profile/jellycotton.bsky.social

### License
Copyright (c) 2026 Jelly

### Usage Terms
This software is provided for personal use.
Redistribution and commercial use are not permitted.
For any other use, please contact the author.

## Utility Tools for DPI & Debugging

Two independent tools are provided in the `tools/` directory to help diagnose and solve DPI/Scaling issues.

### 1. DPI/Rect Diagnosis Tool (`tools/CrossPointRectDiagnosis.exe`)
**Purpose**: Diagnose whether CrossPoint follows the canonical rule (**rect = client-area logical px**). This tool does not save or apply correction coefficients.

**Usage**:
1. Run `tools/CrossPointRectDiagnosis.exe`.
2. Click **"Show Target"** to display a red rectangle of known physical size.
3. Open `CrossPoint` and use **"Set Plate"** to capture EXCLUSIVELY the red area of the target window (exclude title bars).
4. Copy the State JSON from CrossPoint.
5. In the tool, click **"Paste & Analyze"**.
6. The tool prints scale ratios (ideal is ~1.0).

### 2. Dummy Window Generator (`tools/CrossPointDummyJsonWindow.exe`)
**Purpose**: Verify if a State JSON correctly maps to physical screen coordinates by spawning a dummy window at the exact location specified in the JSON.

**Why use this?**
- To verify if the AI-generated JSON aligns with the intended UI elements on your screen.
- It uses `rect` **as-is (no ui_scale division)** and best-effort aligns the **client-area origin**.

**Usage**:
1. Run `tools/CrossPointDummyJsonWindow.exe`.
2. Paste any **State JSON** (e.g., generated by AI or copied from CrossPoint) into the text box.
3. Click **"Spawn Window"**.
4. A gray window will appear.
   - Its **Client Area** (inner size) will match the `rect` in the JSON.
   - A **Red Cross** will mark the `cross` position.
   - A **Blue Button** will mark the `subrect` position (if present).

**For AI Agents**:
When debugging coordinate issues, ask the user to:
1. Copy the JSON you generated.
2. Paste it into this tool.
3. Report back if the window aligns effectively with the target UI.
